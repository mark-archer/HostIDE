
run "./examples/annTypes.host"

fn getSynapses(neuron): filter synapses s : == s.target neuron
fn checkNeurons(): filter neurons n: n.isCheck
fn inputNeurons(): filter neurons n: n.isInput
fn predictorNeurons(): filter neurons n: n.isPredictor


fn newMemory(sourceN)
    var m : new Neuron
    set m.isMem true
    var s : new Synapse sourceN m
    m

fn newPredictor(n2p)
    var p : new Neuron
    set p.isPredictor true
    set p.right 0
    set p.wrong 0

    ;;;
    ; add a connection from every other neuron to the predictor
    each neurons n
        if (!= p n)
            new Synapse n p
            ;set p.threshold : + p.threshold 1
    ;;;

    ; add check neuron for predictor
    var c : new Neuron
    new Synapse p c

    set c.isCheck true
    set c.checkNeuron n2p
    set c.predictor p

    ; return predictor neuron
    p


fn newInput()
    ; create input, memory and predictor
    var i : new Neuron isInput=true
    var m1 : newMemory i

    newPredictor i

    ; return input neuron
    i


var stepCnt 0
fn annStep(inputFn=null)
    set stepCnt : + stepCnt 1

	;; part 1 -- update internal values
	each neurons n
	    set n.value 0
	each synapses s
	    set s.active1 s.active
	    set s.active s.source.active
	    if s.active
	        set s.target.value : + s.target.value s.weight

	;; part 2 -- update active state
	each neurons n
	    if n.isInput continue!
	    set n.active : >= n.value n.threshold
	if inputFn: inputFn!

	;; part 3 -- update incorrect predictors
    updatePredictors!

    ;; return printed neurons
	map neurons n: printN n

fn updatePredictors()
	each neurons c
		if(not c.isCheck) continue!
		var i c.checkNeuron
		if (== c.active i.active)
		    continue!

        var p c.predictor
		each synapses s
			if(!= p s.target) continue!
			if(AND s.active1 c.active)
				set s.weight : - s.weight 1
			if(AND s.active1 (not c.active))
			    set s.weight : + s.weight 1


fn printN(n)
    + "nid:" n.id "=" : + 0 n.active : <<
        var active 0
        var inactive 0
        each synapses s
            if (== s.target n)
                if s.active
                    set active : + active 1
                else
                    set inactive : + inactive 1
        + "  sOn="  active  "  sOff=" inactive
        >> + "  v=" n.value "  t=" n.threshold
        >> + " mx=" : OR n.multiplier 0
        if n.isCheck
            >> + "  check=" (== n.active n.checkNeuron.active)
        elif n.isInput
            >> + "  input"
        elif n.isPredictor
            >> + "  predictor"
        elif n.isMem
            >> + "  memory"


fn printP()
	var c : first : filter neurons n : n.isCheck
	var p c.predictor
	var str : +
	    + "t=" stepCnt "\n"
	    printN c.checkNeuron
	    "\n"
	    printN c
	    "\n"
	    printN p
	    "\n"

	each synapses s
		if(!= s.target p) continue!
        set str : + str "\n"
            + "sid=" s.source.id " sOn="
            cond
            	s.active "1"
            	true: "0"
            + " w=" s.weight
	str


;; build ann to test prediction
fn annPredict()
    var n : new Neuron isInput=true active=true
    var i1 n
    for (i 4)
        set n : newMemory n
    var p : newPredictor i1

    ; add a connection from every other neuron to the predictors
    each neurons p
        if(not p.isPredictor) continue!
        each neurons n
            if n.isCheck continue!
            if (== p n) continue!
            new Synapse n p
            set p.threshold : + p.threshold 1


;; build ann to play tic-tac-toe
fn annTTT()
    for(i 1 27)
        newInput!







